### 1. **Heap Sort Algorithm**  
**Description:**  
This project implements the **Heap Sort Algorithm** in Python, showcasing how to efficiently sort a list of integers using the properties of a **Max Heap**. The program starts by building a Max Heap from the input list, ensuring the largest element is at the root. It then repeatedly extracts the largest element, adds it to the sorted list, and adjusts the heap structure to maintain the Max Heap property. The project demonstrates core concepts of heap operations, including **heapify**, **build heap**, and **sorting using heaps**.  

**Features:**  
- Implements a custom heap-based sorting algorithm.  
- Provides a step-by-step breakdown of Max Heap construction and element extraction.  
- Demonstrates efficient use of recursive functions and in-place swapping for heap operations.  

**Use Cases:**  
Ideal for learning the mechanics of heap-based sorting and understanding its **O(n log n)** time complexity.

---

### 2. **Kruskalâ€™s Minimum Spanning Tree (MST) Algorithm**  
**Description:**  
This project demonstrates **Kruskal's Algorithm** for finding the **Minimum Spanning Tree (MST)** of a graph. The implementation is in Python and uses the **Greedy Algorithm** approach. It processes all graph edges in ascending order of weight, ensuring that no cycles are formed while connecting all vertices with the minimum total weight. The project uses a **Disjoint Set Union (DSU)** structure with path compression and union by rank to efficiently manage connected components.  

**Features:**  
- Implements Kruskal's Algorithm to compute the MST for an undirected, weighted graph.  
- Includes functions for sorting edges, union-find operations, and cycle detection.  
- Prints the edges included in the MST and the total cost of the spanning tree.  

**Use Cases:**  
Great for understanding graph theory concepts, particularly MSTs, and applying greedy algorithms for optimization problems.  
